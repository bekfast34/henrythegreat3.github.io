<!DOCTYPEhtml>
<html
      	<body onkeydown="keypress(event)" onkeyup="keyup(event)">
		<div id="menu">
			<input type='file' onchange="getImage(this);" />
			<label for ="full">Fullscreen</label>
			<input type="checkbox" id="full" class="check" onchange = "fullScreen(this);">
		</div>
		<canvas id = "canvas"></canvas>
		<canvas id="3dCanvas"></body>
</body>
</html>
<style>
    		*{
			margin:0;
			padding:0;
		}
		#menu{
			position:fixed;
			width:100vw;
			height:4em;
			background:rgba(0,0,0,0.5);
			overflow:hidden;
		}
		#menu input{
			height:5em;
			margin-top:0;
			float:left;
			font-family: Helvetica;
			padding-top:1.5em;
			margin-left:1em;
		}
		.check{
			width:2em;
			height:3em;
		}
		label{
			float:left;
			height:4em;
			line-height:4em;
			font-family: Helvetica;
		}
		canvas{
			margin-top:4em;
		}
</style>
<script>
    const map = [];
			const canvas = document.getElementById("canvas");
			const Canvas3D = document.getElementById("3dCanvas");
			const ctx3D = Canvas3D.getContext("2d");
			const ctx = canvas.getContext("2d");
			const blockSize = 20;
			let displayMinMap = true;
			var mapWidth = 0;
			var mapHeight = 0;
			let imageLoaded = false;
			let playerObj;
			const keys = [];
			const maxRays = 80;
			const pov = 0.5;
			const rayMaxLength = 300;
			function Premap(){
				map.length = 0;
				loadMap(map,"http://i.imgur.com/kIANaMg.png");
			}
			function fullScreen(obj){
				console.log(obj.checked);
				if(obj.checked){
					canvas.style.display = "none";
					Canvas3D.width = window.innerWidth;
					Canvas3D.height = window.innerHeight;
					displayMinMap = false;
				}
				else{
					canvas.style.display = "inline-block";
					Canvas3D.width = 640;
					Canvas3D.height = 360;
					displayMinMap = true;
				}
			}
			const loadMap = function(map, imageSource){
				const image = new Image();
				image.crossOrigin = "";
				image.onload = function(){
					imageLoaded = true;
					let canvas = document.createElement("canvas");
					let ct = canvas.getContext("2d");
					ct.drawImage(image,0,0);
					mapWidth = image.width;
					mapHeight = image.height;
					let data = ct.getImageData(0,0,image.width,image.height);
					console.log(data);
					let w = 0;
					for(let i = 0; i < data.data.length; i += 4){
						map.push(data.data[i] & 0x1);
					}
					doStuff();
				}
				image.src = imageSource;
			}
			const drawMap = function(map){
				ctx.fillStyle = "black";
				for(let i = 0; i < mapHeight; i++){
					for(let j = 0; j < mapWidth; j++){
							if(!map[j + i*mapWidth])
								ctx.fillRect(j*blockSize,i*blockSize,blockSize,blockSize);
						}
				}
			}

			function doStuff(){
				playerObj = new Player();
				Canvas3D.style.background = "lightgray";
				Canvas3D.width = 640;
				Canvas3D.height = 360;
				resizeCanvas();
				update();
			}
			function update(){
				let ray = rays(playerObj,maxRays,pov,rayMaxLength);
				ctx.clearRect(0,0,canvas.width,canvas.height);
				playerObj.updatePosition();
				drawWalls(ray);
				if(displayMinMap){
					drawMap(map);
					drawRays(ray);
					ctx.fillStyle = "red";
					ctx.fillRect(playerObj.position[0],playerObj.position[1],10,10);
					ctx.beginPath();
					ctx.moveTo(playerObj.position[0] + 5,playerObj.position[1] + 5);
					ctx.lineTo(playerObj.position[0] + 5 + (20 * Math.cos(Math.radians(playerObj.rotation))),playerObj.position[1] + 5 + (20 * Math.sin(Math.radians(playerObj.rotation))));
					ctx.stroke();
					ctx.closePath();
				}
				requestAnimationFrame(update);
			}		
			function resizeCanvas(){
				canvas.width = mapWidth * blockSize;
				canvas.height = mapHeight * blockSize;
			}
			Math.radians = function(degrees) {
			  return degrees * Math.PI / 180;
			};
			const Player = function(){
				this.position = [blockSize + 15,blockSize + 5];
				this.speed = 1;
				this.rotationSpeed = 2;
				this.rotation = 0;
				this.updatePosition = function(){
					//left
					if(keys[65])
						this.rotation -= this.rotationSpeed;
					//right
					if(keys[68])
						this.rotation += this.rotationSpeed;
					//up
					if(keys[87]){
						let newPos = [this.position[0] + this.speed * Math.cos(Math.radians(playerObj.rotation)), this.position[1] + this.speed * Math.sin(Math.radians(playerObj.rotation))];
						if(!Colliding(newPos))
							this.position = newPos;

					}
					//down
					if(keys[83]){
						let newPos = [this.position[0] - this.speed * Math.cos(Math.radians(playerObj.rotation)), this.position[1] - this.speed * Math.sin(Math.radians(playerObj.rotation))];
						if(!Colliding(newPos))
						this.position = newPos;
					}
				}
			}
			function drawWalls(rays){
				let ratio = Canvas3D.height / Canvas3D.width;
				ctx3D.clearRect(0,0,Canvas3D.width,Canvas3D.height);
				let strokeWidth = Canvas3D.width / rays.length;
				for(let i = 0; i < rays.length; i++){
					let strokeHeight = maxRays / rays[i][2];
					let normLength = rays[i][2] / rayMaxLength;
					//console.log("length: " + rays[i][2]);
					ctx3D.fillStyle = "rgba(0,0,0," + (1 - normLength) + ")";
					ctx3D.fillRect(i*strokeWidth,Canvas3D.height / 2 - (Canvas3D.height * (strokeHeight) * ratio) / 2, strokeWidth, Canvas3D.height * (strokeHeight) * ratio);
				}
					//ctx3D.fillRect(0,Canvas3D.height / 2 - (Canvas3D.height / 2) / 2,10,Canvas3D.height / 2);
			}
			function hypo(x,y){
				return Math.sqrt(x*x + y*y);
			}
			function rays(player, amt,pov,rayLength){
				var rays = [];
				let rayPosition = [player.position[0] + 5,player.position[1] + 5];
				let currentRayLength = 0;
				for(let i = 0; i < amt; i++){
					rayPosition = [player.position[0] + 5,player.position[1] + 5];
					currentRayLength = 0; 
					while(!rayCollision(rayPosition) && currentRayLength < rayLength){
						currentRayLength ++;
						rayPosition[0] = player.position[0] + 5 + (currentRayLength * Math.cos(Math.radians(player.rotation + (i*pov - (amt * pov)/2))));
						rayPosition[1] = player.position[1] + 5 + (currentRayLength * Math.sin(Math.radians(player.rotation + (i*pov - (amt * pov)/2))));
					}
					rays.push(
						[
						player.position[0] + 5 + (currentRayLength * Math.cos(Math.radians(player.rotation + (i*pov - (amt * pov)/2)))),
						player.position[1] + 5 + (currentRayLength * Math.sin(Math.radians(player.rotation + (i*pov - (amt * pov)/2)))),
						player.position[2] = currentRayLength
						]);
				}
				return rays;
			}
			function drawRays(rays){

				for(let i = 0; i < rays.length; i++){
					ctx.beginPath();
					ctx.strokeStyle = "green";
					ctx.moveTo(playerObj.position[0] + 5,playerObj.position[1] + 5);
					ctx.lineTo(rays[i][0],rays[i][1]);
					ctx.stroke();
					ctx.closePath();
				}
			}
			function Colliding(pos){
				let posX = Math.floor(pos[0] / blockSize);
				let posY = Math.floor(pos[1] / blockSize);
				let widthPos = Math.floor((pos[0] + 10) / blockSize);
				let heightPos = Math.floor((pos[1] + 10) / blockSize);
				return (map[posX + posY*mapWidth] == 0 || map[widthPos + posY*mapWidth] == 0 || map[posX + heightPos*mapWidth] == 0|| map[widthPos + heightPos*mapWidth] == 0);

			}
			function rayCollision(pos){
				let posX = Math.floor(pos[0] / blockSize);
				let posY = Math.floor(pos[1] / blockSize);
				if(pos[0] < 0 || pos[0] > canvas.width || pos[1] < 0 || pos[1] > canvas.height) return true;
				return (map[posX + posY*mapWidth] == 0);
			}
			function keypress(event){
				console.log(event.keyCode);
				keys[event.keyCode] = true;
			}
			function keyup(event){
				keys[event.keyCode] = false;
			}
			function getImage(input) {
				map.length = 0;
			    let src = URL.createObjectURL(event.target.files[0]);
			    loadMap(map,src);
			}	
         Premap();
</script>
